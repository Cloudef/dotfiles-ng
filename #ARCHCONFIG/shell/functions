#!/bin/sh
# Systemwide shell functions
#

#########################
## Colorized man pages ##
#########################
man() {
   env \
      LESS_TERMCAP_mb=$(printf "\e[1;31m") \
      LESS_TERMCAP_md=$(printf "\e[1;31m") \
      LESS_TERMCAP_me=$(printf "\e[0m") \
      LESS_TERMCAP_se=$(printf "\e[0m") \
      LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
      LESS_TERMCAP_ue=$(printf "\e[0m") \
      LESS_TERMCAP_us=$(printf "\e[1;32m") \
      man "$@"
}

#####################################
## Take screenshot of main monitor ##
#####################################
shot() {
   local mon=$@
   local file="$HOME/shot-$(date +'%H:%M-%d-%m-%Y').png"
   [ "$mon" ] || mon=1
   ffcast -x $mon % scrot -g %wx%h+%x+%y $file
}

##############################################
## Colored Find                             ##
## NOTE: Searches current tree recrusively. ##
##############################################
f() {
   find . -iregex ".*$@.*" -printf '%P\0' | xargs -r0 ls --color=auto -1d
}

################
## Smarter CD ##
################
function goto() {
   [ -d "$1" ] && cd "$1" || cd "$(dirname "$1")";
}

####################
## Copy && Follow ##
####################
function cpf() {
   cp "$@" && goto "$_";
}

####################
## Move && Follow ##
####################
function mvf() {
   mv "$@" && goto "$_";
}

#####################
## mkdir && follow ##
#####################
function mkcdr() {
   mkdir -vp "$@" && cd "$_";
}

##################
## Start daemon ##
##################
function start() {
   sudo rc.d start $@
}

#################
## Stop daemon ##
#################
function stop() {
   sudo rc.d stop $@
}

####################
## Restart daemon ##
####################
function restart() {
   sudo rc.d stop  $@
   sudo rc.d start $@
}

###################
## Daemon status ##
###################
function status() {
   rc.d list $@
}

########################
## Print window class ##
########################
xclass()
{
   xprop |awk '
   /^WM_CLASS/{sub(/.* =/, "instance:"); sub(/,/, "\nclass:"); print}
   /^WM_NAME/{sub(/.* =/, "title:"); print}'
}

###################################################################
## Valgrind wrapper, use valgrind.supp for suppressions if found ##
###################################################################
memleak()
{
   [ -f valgrind.supp ] &&
      valgrind --suppressions=valgrind.supp "$@" || valgrind "$@"
}

########################
## Create tar archive ##
########################
function mktar() {
   tar cvf  "${1%%/}.tar" "${1%%/}/";
}

###########################
## Create tar.gz archive ##
###########################
function mktgz() {
   tar cvzf "${1%%/}.tar.gz"  "${1%%/}/";
}

############################
## Create tar.bz2 archive ##
############################
function mktbz() {
   tar cvjf "${1%%/}.tar.bz2" "${1%%/}/";
}

######################
## Extract archives ##
######################
function extract() {
   # Allow work with wildcards
   while [ "$1" ]; do
      if [ -f "$1" ] ; then
         case "$1" in
            *.tar.bz2)   tar xvjf "$1"    ;;
            *.tar.gz)    tar xvzf "$1"    ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar x "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xvf "$1"     ;;
            *.tbz2)      tar xvjf "$1"    ;;
            *.tgz)       tar xvzf "$1"    ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *)           echo "don't know how to extract '$1'..." ;;
         esac
      else
         echo "'$1' is not a valid file"
      fi
      shift || break
   done
}

#####################################################
## Remux MKV to use only 1 audio && subtible track ##
#####################################################
remux() {
   if [ ! "$1" ] || [ ! "$2" ] || [ ! "$3" ] || [ ! "$4" ]; then
      echo "usage : remux [output] [input] [audio track to keep] [subtible track to keep]"
      return
   fi
   mkvmerge -o "$1" -d 1 --audio-tracks "$3" --subtitle-tracks "$4" "$2"
}

#####################################################################
## Same as earlier, expect you can batch whole directory with this ##
#####################################################################
bremux() {
   local FILTER="*.mkv"
   if [ ! "$1" ] || [ ! "$2" ]; then
      echo "usage : bremux [audio track] [subtible track] [filter]"
      return
   fi
   [ "$3" ] && FILTER="$3"
   for i in $FILTER
   do
      remux "[REMUX]$i" "$i" "$1" "$2"
   done
}

############################################################
## Print MKV info, use this to find out the track numbers ##
############################################################
mkv() {
   if [ ! "$1" ]; then
      echo "usage : mkv [file]"
      return
   fi
   mkvmerge -i "$@"
}

##################################
## Compress && Strip elf binary ##
##################################
elfcompress() {
   if [ ! "$1" ]; then
      echo "usage : elfcompress [binary]"
      return
   fi

   cp "$1" /tmp/compress.temp
   strip -s -R .comment -R .gnu.version /tmp/compress.temp

   7z a -tGZip -mx=9 /tmp/compress.gz /tmp/compress.temp
   echo 'a=/tmp/I;tail -n+2 $0|zcat>$a;chmod +x $a;$a;rm $a;exit' >> /tmp/unpack.header

   cat /tmp/unpack.header /tmp/compress.gz > "$1.packed"
   chmod +x "$1.packed"

   rm /tmp/compress.temp
   rm /tmp/compress.gz
   rm /tmp/unpack.header
}

##################################################
## Convert ISO to splitted WBFS to use with Wii ##
##################################################
wiisplit()
{
   if [ ! "$1" ]; then
      echo "usage: wiisplit [ISO file]"
      return
   fi
   if [ ! -f "$1" ]; then
      echo "'$1' is not a valid file"
      return
   fi

   wbfs_file "$1"
}

######################################
## Open file inside git tree on vim ##
######################################
vimo() {
   local match=
   local gtdir=
   git ls-files &>/dev/null || return # test if git
   gtdir="$(git rev-parse --show-toplevel)"
   pushd "$gtdir" &> /dev/null # git root
   [ "$@" ] && match="$(git ls-files | grep "$@")" ||
               match="$(git ls-files)"
   [[ $(echo "$match" | wc -l) -gt 1 ]] && match="$(echo $match | dmenu -i -l 20 -p "vim")"
   match="$gtdir/$match" # convert to absolute
   popd &> /dev/null # go back
   [[ -f "$match" ]] || return
   vim "$match"
}

#######################
## Setup github repo ##
#######################
function mkgit() {
   local GITHUB="Cloudef"

   mkdir "$1"
   cd "$1"
   git init
   touch README
   git add README
   git commit -a -m 'inital setup - automated'
   git remote add origin "git@github.com:$GITHUB/$1.git"
   git push -u origin master
}

####################################
## Getting undefined references?  ##
## Grep your libs for symbols     ##
####################################
function greplib() {
   if [ ! "$1" ]; then
      echo "usage : greplib [symbol] (lookup path)"
      return
   fi

   if [ ! "$2" ]; then
      nm -a -o /usr/lib/*.so 2> /dev/null | grep $1
      nm -a -o /usr/lib/*.a  2> /dev/null | grep $1
   else
      nm -a -o $2/*.so 2> /dev/null | grep $1
      nm -a -o $2/*.a  2> /dev/null | grep $1
   fi
}

##############################
## Encode GLC captured file ##
##############################
glc-encode() {
   if [ ! "$1" ] || [ ! "$2" ] || [ ! "$3" ] || [ ! "$4" ]; then
      echo "Usage : glc-encode [input] [audio bitrate] [video bitrate] [output]"
      return
   fi

   [[ "$2" == "0" ]] || glc-play "$1" -o - -a 1 | ffmpeg -i pipe: -ab $2 /tmp/audio.mp4
   if [ -f /tmp/audio.mp4 ]; then
      glc-play "$1" -o - -y 1 | ffmpeg -i pipe: -i /tmp/audio.mp4 -acodec copy -b $3 "$4"
      rm /tmp/audio.mp4
   else
      glc-play "$1" -o - -y 1 | ffmpeg -i pipe: -b $3 "$4"
   fi
}

#############################
## Japanese text to speech ##
#############################
say() {
   local URL="$(echo "$@" | perl -MURI::Escape -ne 'chomp;print uri_escape($_)')"
   mplayer -really-quiet "http://translate.google.com/translate_tts?ie=UTF-8&tl=JA&q=$URL" &> /dev/null
}

######################################
## Crappy google translate [JA->EN] ##
######################################
translate() {
   local URL="$(echo "$@" | perl -MURI::Escape -ne 'chomp;print uri_escape($_)')"
   curl -s -A "Mozilla" "http://translate.google.com/translate_a/t?client=t&ie=UTF-8&text=$URL&sl=ja&tl=en" | awk -F'"' '{print $2}'
}
