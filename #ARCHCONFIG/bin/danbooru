#!/bin/bash
# Crawl danbooru for pictures
#

# -- Fri Apr 12 18:36:21 UTC 2013
# Danbooru API changed!
# Still no artist information in post json...
# This script is not compatible with old danbooru storage format anymore.
#
# artists.db format changed again, to store only artist name.
# We only accept artists which name match the tag exactly,
# to avoid issues where tag was guessed as artist (ex. panties)
#
# More filtering options also provided.
# .meta and .tags files no longer exists, instead .json file is provided!
#
# Also jsawk dependency is dropped for jshon dependency.

# ABOUT
# -----
# Uses JSON API instead of crawling HTML.
# Much fool proof and allows more control.
# Also it won't bloat your directory with lots of images, that slows down various file browsers.
#
# The script does lots of caching since crawling always web is slow.
# So while you run the script few times, it starts getting faster.

# Limit requests
# Why? See: http://danbooru.donmai.us/forum/show/72300
#
# If you are calling this script in for loop, you should call sleep each iteration.

# Local directory where to store the posts
LOCAL_STORE="/mnt/storage/pictures/danbooru"

# Directory structure for storing posts
# Following keys can be used:
#  %extension: file extension (.jpg, .png, ...)
#  %artist:    artist of the post
#  %rating:    rating of the post (safe, questionable, explicit)
#  %postid:    id of the post
#  %pool:      pool of the post (replaced as 'nopool' when post has no pool)
#  %md5:       md5 of the post
#
# Example of default format:
# /danbooru/Rib_y(uhki)/safe/dd192a8639f36f3fa38e551d0f24d73c.jpg"
#
# Duplicate detection breaks, if you change this after crawling
#
# Use -v flag to doublecheck that your filepaths looks sane
# This script does no sanity checking to this
LOCAL_FORMAT="%artist/%rating/%md5.%extension"

# Filename expression
# Set characters which you want stripped from filename, eg, if you use fat32.
FILENAME_EXP='s/[][%\+\\\"\*;:\?\|<>,=]/_/g'

# Artist database
# Since danbooru API allows no easy way to get artist from post,
# it needs to be crawled, and this is _really_ slow.
#
# We can workaround it by keeping local artist cache, which will speed up things eventually.
ARTIST_DB="$LOCAL_STORE/artist.db"

# Ignore database
# Another speedup method!
# Stores all tags here that are not linked to any artist
IGNORE_DB="$LOCAL_STORE/ignore.db"

# Rating to download
# s = Only download safe posts
# q = Download questionable && safe posts
# e = Download explicit && questionable && safe posts
DANBOORU_RATING="e"

# Download only posts that are higher than this score
DANBOORU_SCORE=0

# Download pending posts?
DANBOORU_PENDING=0

# Download deleted posts?
DANBOORU_DELETED=0

# Download flagged posts?
DANBOORU_FLAGGED=0

# Download non rating locked posts?
DANBOORU_NON_RATING_LOCKED=1

# Download non status locked posts?
DANBOORU_NON_STATUS_LOCKED=1

# Download non note locked posts?
DANBOORU_NON_NOTE_LOCKED=1

# Download only parent posts
DANBOORU_ONLY_PARENT=0

# Download posts with no artist tag?
DANBOORU_NO_ARTIST=0

# Download only posts matching following dimensions
# Leave array blank to download everything
# ex. ("1680x1050" "800x600")
DANBOORU_LIMIT_DIMENSIONS=()

# Filter tags
# Posts which match one of these tags will not be downloaded
DANBOORU_TAG_FILTER=("yaoi" "tiger_&_bunny" "boys_love" "shounen-ai")

# Tag match
# Only posts which match one of these tags will be downloaded
DANBOORU_TAG_MATCH=()

# Filter pools
# Posts which match one of these pools will not be downloaded
DANBOORU_POOL_FILTER=()

# Pool match
# Only posts which match one of these pools will be downloaded
DANBOORU_POOL_MATCH=()

# Limit the number of sub processes for download
FORK_LIMIT=20

# Lock file
TMP_DIR="/tmp/danbooru"
LOCK_FILE="$TMP_DIR/lock"

# Danbooru API root
DANBOORU_ROOT="http://danbooru.donmai.us"

# Danbooru user && api key
source "/arch/passwd/libpasswd-sh"
DANBOORU_USER="$(_passwd_get_user "danbooru")"
DANBOORU_API_KEY="$(_passwd_get_pass "danbooru")"

# Curl agent
CURL_AGENT="Mozilla/4.73 [en] (X11; U; Linux 2.2.15 i686)"

# Depencies for this script
# Perl is used for url encoding tags
BIN_DEPS="curl jshon perl"
VERBOSE=0

error()
{
   unlock
   echo "$@"
   exit 1
}

error_no_unlock()
{
   echo "$@"
   exit 1
}

check_deps()
{
   hash $BIN_DEPS
   [[ $? -eq 0 ]] || error_no_unlock "Depencies missing! Bail out..."
}

# Lock
lock()
{
   [[ -d "$TMP_DIR"     ]] || mkdir -p "$TMP_DIR"
   [[ ! -f "$LOCK_FILE" ]] || error_no_unlock "$(basename "$0") is already running!"
   touch "$LOCK_FILE"
}

# Unlock
unlock()
{
   [[ -f "$LOCK_FILE" ]] && rm "$LOCK_FILE"
   [[ -d "$TMP_DIR"   ]] && rm -r "$TMP_DIR"
}

# Signal handler
sigint()
{
   # Kill all sub processes
   test -z "`jobs -p`" || kill -9 `jobs -p` &> /dev/null

   # Unlock
   unlock

   echo "$(basename "$0"): SIGINT"
   exit 1
}

# Usage
usage()
{
   for i in $@; do
      [[ "$i" != "-h" ]] && [[ "$i" != "--help" ]] || error_no_unlock "$(basename "$0") (-v) [page] [tags] [limit]"
      [[ "$i" != "-v" ]]                           || VERBOSE=1
   done
}

# Encode urls
# $1 = URL
urlencode()
{
   echo -n "$@" | perl -pe's/([^-_.~A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg'
}

# $1 = API URL
# $2 = URL Arguments
get_json()
{
   curl -s --user-agent "$CURL_AGENT" "$DANBOORU_ROOT/$1.json?$2&login=$DANBOORU_USER&api_key=$DANBOORU_API_KEY"
}

# $1 = JSON rating
# Return readable rating
rating_str()
{
   [[ "$@" != "s" ]] || echo "safe"
   [[ "$@" != "q" ]] || echo "questionable"
   [[ "$@" != "e" ]] || echo "explicit"
}

# $1 = Artist name
# Caches artist to DB file
cache_artist()
{
   [[ -n "$@" ]] || return
   [[ $VERBOSE -eq 1 ]] && echo "caching artist: $@"
   echo "$1 $2" >> "$ARTIST_DB"
}

# $1 = Artist name
# Return artist, if matching artist is found from artist cache
check_artist()
{
   [[ -n "$@"         ]] || return
   [[ -f "$ARTIST_DB" ]] || return
   grep -wF "$@" "$ARTIST_DB" | head -n1
}

# $1 = Tag
# Caches tag to ignore file
cache_ignore()
{
   [[ -n "$@" ]] || return
   [[ $VERBOSE -eq 1 ]] && echo "caching ignore tag: $@"
   echo "$@" >> "$IGNORE_DB"
}

# $1 = Matching tag
# Return tag, if matching tag is found from ignore cache
check_ignore()
{
   [[ -n "$@"         ]] || return
   [[ -f "$IGNORE_DB" ]] || return
   grep -wF "$@" "$IGNORE_DB" | head -n1
}

# $1 = Post JSON
# $2 = Artist
# Returns target from configured format
#  %extension: file extension (.jpg, .png, ...)
#  %artist:    artist of the post
#  %rating:    rating of the post (safe, questionable, explicit)
#  %postid:    id of the post
#  %pool:      pool of the post (replaced as 'nopool' when post has no pool)
#  %md5:       md5 of the post
target_from_format()
{
   local JSON="$1"
   local ARTIST="$2"
   [[ -n "$JSON" ]] || return

   ID="$(echo "$JSON" | jshon -e "id" -u)"
   MD5="$(echo "$JSON" | jshon -e "md5" -u)"
   EXT="$(echo "$JSON" | jshon -e "file_ext" -u)"
   POOL="$(echo "$JSON" | jshon -e "pool_string" -u)"
   RATING="$(echo "$JSON" | jshon -e "rating" -u)"
   RATING="$(rating_str "$RATING")"
   [[ -n "$POOL"   ]] || POOL="nopool"
   [[ -n "$ARTIST" ]] || ARTIST="noartist"

   TARGET="$(echo "$LOCAL_FORMAT" |\
      sed "s/%extension/$EXT/;s/%artist/$ARTIST/;s/%rating/$RATING/;s/%postid/$ID/;s/%pool/$POOL/;s/%md5/$MD5/")"
   TARGET=$(echo -n "$TARGET" | sed "$FILENAME_EXP") # Replace illegal characters.
   echo "$LOCAL_STORE/$TARGET"
}

# $1 = URL
# $2 = Touch date
# $3 = JSON
# $4 = Target
# Download picture
store_picture()
{
   local URL="$1"
   local DATE="$2"
   local JSON="$3"
   local TARGET="$4"

   # Temp target
   local BASE="$(basename "$URL")"
   local TEMP="$TMP_DIR/$BASE"

   # Download to $TEMP and move after finished to
   # destination to avoid partial downloads
   echo "==> [D] $URL"
   echo "     => $TARGET"
   curl -s -o "$TEMP" "$URL"

   # Download failed
   [[ -f "$TEMP" ]] || return

   # Check corrupt file
   MD5="$(md5sum "$TEMP")"
   MD5="${MD5%% *}"
   [[ "$MD5" == "${BASE%.*}" ]] || {
      echo "[!] Removing corrupt: $TEMP";
      rm "$TEMP"; return;
   }

   # mkdir
   mkdir -p "$(dirname $TARGET)"

   # Move to destination
   mv "$TEMP" "$TARGET"
   [[ -n "$DATE" ]] && touch -c -d "$DATE" "$TARGET"
   echo "$JSON" > "${TARGET%.*}.json"
}

# $1 = URL
# $2 = Danbooru URL
# $3 = Tags
# $4 = Touch date
# $5 = JSON
# Stores the picture
check_picture()
{
   local URL="$1"
   local DURL="$2"
   local TAGS="$3"
   local DATE="$4"
   local JSON="$5"

   local RESULT=
   local ARTIST=
   local MATCH=

   [[ -n "$URL"  ]] || return
   [[ -n "$DURL" ]] || return
   [[ -n "$JSON" ]] || return

   # Check cache second
   [[ $VERBOSE -eq 0 ]] || echo "local artist lookup"
   for ETAG in $TAGS; do
      ARTIST="$(check_artist "$ETAG")"
      [[ -n "$ARTIST" ]] && { MATCH="$ETAG"; break; }
   done

   # If no match in cache, get from danbooru
   if [[ ! -n "$MATCH" ]]; then
      [[ $VERBOSE -eq 0 ]] || echo "remote artist lookup"
      for ETAG in $TAGS; do
         [[ -n "$(check_ignore "$ETAG")" ]] && continue
         RESULT="$(get_json "artists" "search\[name\]=$(urlencode "$ETAG")")"
         [[ -n "$RESULT" ]] || { cache_ignore "$ETAG"; continue; }
         [[ "$RESULT" != "[]" ]] && {
            JSONCNT=$(echo "$RESULT" | jshon -l)
            for i in $(seq 0 $((JSONCNT-1))); do
               ACTIVE="$(echo "$RESULT" | jshon -e $i -e "is_active" -u 2>/dev/null)"
               [[ "$ACTIVE" == "true" ]] || continue
               CARTIST="$(echo "$RESULT" | jshon -e $i -e "name" -u 2>/dev/null)"
               [[ "$CARTIST" == "$ETAG" ]] || continue
               ARTIST="$CARTIST"
               cache_artist "$ARTIST"
               break;
            done
            [[ -n "$ARTIST" ]] && break || cache_ignore "$ETAG" # found
         } || cache_ignore "$ETAG"
      done
   fi

   # Check that artist lookup succeed
   if [[ ! -n "$ARTIST" ]]; then
      echo "[!!] failed to crawl artist: $DURL"
      [[ $DANBOORU_NO_ARTIST -eq 1 ]] || return
      ARTIST="noartist"
   else
      ARTIST=$(echo -n "$ARTIST" | sed 's/ //g') # Strip all spaces
   fi

   # Check if file already exists
   TARGET="$(target_from_format "$JSON" "$ARTIST")"
   [[ $VERBOSE -eq 0 ]] || echo ":: TARGET IS: $TARGET"
   [[ -n "$TARGET" ]] || return
   if [[ -f "$TARGET" ]]; then
      echo "[!] exist [$(basename $TARGET)]: $DURL"
      return
   fi

   # Download picture to disk
   store_picture "$URL" "$DATE" "$JSON" "$TARGET" &
}

# Main
main()
{
   # Get rid of the verbose argument
   [[ $VERBOSE -eq 0 ]] || shift 1

   local RESULT=
   local LIMIT="${3-100}"
   local PAGE="${1-1}"
   local PTAGS="$(urlencode "$2")"
   local OK=0

   # Trap SIGINT
   trap sigint SIGINT

   [[ $VERBOSE -eq 0 ]] || echo "$DANBOORU_ROOT/posts.json?page=$PAGE&limit=$LIMIT&tags=$PTAGS"
   RESULT="$(get_json "posts" "page=$PAGE&limit=$LIMIT&tags=$PTAGS")"
   JSONCNT=$(echo "$RESULT" | jshon -l)

   for i in $(seq 0 $((JSONCNT-1))); do
      JSON="$(echo "$RESULT" | jshon -e $i 2>/dev/null)"
      [[ -n "$JSON" ]] || error "[!] No results.."

      # Parse stuff we need
      PENDING="$(echo "$JSON" | jshon -e "is_deleted" -u)"
      BANNED="$(echo "$JSON" | jshon -e "is_banned" -u)"
      DELETED="$(echo "$JSON" | jshon -e "is_deleted" -u)"
      FLAGGED="$(echo "$JSON" | jshon -e "is_flagged" -u)"
      NOTE_LOCKED="$(echo "$JSON" | jshon -e "is_note_locked" -u)"
      STATUS_LOCKED="$(echo "$JSON" | jshon -e "is_status_locked" -u)"
      RATING_LOCKED="$(echo "$JSON" | jshon -e "is_rating_locked" -u)"
      CREATED_AT="$(echo "$JSON" | jshon -e "created_at" -u)"
      RATING="$(echo "$JSON" | jshon -e "rating" -u)"
      SCORE="$(echo "$JSON" | jshon -e "score" -u)"
      WIDTH="$(echo "$JSON" | jshon -e "image_width" -u)"
      HEIGHT="$(echo "$JSON" | jshon -e "image_height" -u)"
      PARENT="$(echo "$JSON" | jshon -e "parent_id" -u)"
      TAGS="$(echo "$JSON" | jshon -e "tag_string" -u)"
      POOL="$(echo "$JSON" | jshon -e "pool_string" -u)"
      ARTISTCNT="$(echo "$JSON" | jshon -e "tag_count_artist" -u)"
      ID="$(echo "$JSON" | jshon -e "id" -u)"
      MD5="$(echo "$JSON" | jshon -e "md5" -u)"
      EXT="$(echo "$JSON" | jshon -e "file_ext" -u)"
      URL="$DANBOORU_ROOT/data/$MD5.$EXT"
      DURL="$DANBOORU_ROOT/posts/$ID"

      # Check artist
      OK=1
      [[ $ARTISTCNT -eq 0 ]] && [[ $DANBOORU_NO_ARTIST -eq 0 ]] && OK=0

      if [[ $OK -eq 0 ]]; then
         echo "[!] no artist: $DURL"
         continue
      fi

      # Check parent
      OK=1
      [[ "$PARENT" != "null" ]] && [[ $DANBOORU_ONLY_PARENT -eq 1 ]] && OK=0

      if [[ $OK -eq 0 ]]; then
         echo "[!] block parent [$PARENT]: $DURL"
         continue
      fi

      # Check score
      OK=1
      [[ $SCORE -ge $DANBOORU_SCORE ]] || OK=0

      if [[ $OK -eq 0 ]]; then
         echo "[!] block score [$SCORE]: $DURL"
         continue
      fi

      # Check rating
      OK=1
      [[ "$RATING" == "e" ]] && { [[ "$DANBOORU_RATING" == "e" ]] || OK=0; }
      [[ "$RATING" == "q" ]] && { [[ "$DANBOORU_RATING" == "q" ]] || [[ "$DANBOORU_RATING" == "e" ]] || OK=0; }
      [[ "$RATING" == "s" ]] && OK=1

      if [[ $OK -eq 0 ]]; then
         echo "[!] block rating [$RATING]: $DURL"
         continue
      fi

      # Check status
      OK=1; STATUS="OK"
      [[ "$BANNED"  == "true" ]] && { OK=0; STATUS="banned"; }
      [[ "$PENDING" == "true" ]] && { [[ $DANBOORU_PENDING -eq 1 ]] || { OK=0; STATUS="pending"; } }
      [[ "$FLAGGED" == "true" ]] && { [[ $DANBOORU_FLAGGED -eq 1 ]] || { OK=0; STATUS="flagged"; } }
      [[ "$DELETED" == "true" ]] && { [[ $DANBOORU_DELETED -eq 1 ]] || { OK=0; STATUS="deleted"; } }
      [[ "$NOTE_LOCKED"   != "true" ]] && { [[ $DANBOORU_NON_NOTE_LOCKED -eq 1 ]]   || { OK=0; STATUS="not note locked"; } }
      [[ "$STATUS_LOCKED" != "true" ]] && { [[ $DANBOORU_NON_STATUS_LOCKED -eq 1 ]] || { OK=0; STATUS="not status locked"; } }
      [[ "$RATING_LOCKED" != "true" ]] && { [[ $DANBOORU_NON_RATING_LOCKED -eq 1 ]] || { OK=0; STATUS="not rating locked"; } }

      if [[ $OK -eq 0 ]]; then
         echo "[!] block status [$STATUS]: $DURL"
         continue
      fi

      # Check pool
      OK=1; BPOOL=""
      for EPOOL in "${DANBOORU_POOL_FILTER[@]}"; do
         [[ "$EPOOL" != "$POOL" ]] && continue
         OK=0; BPOOL="$EPOOL"
         break
      done

      if [[ $OK -eq 0 ]]; then
         echo "[!] block pool [$BPOOL]: $DURL"
         continue
      fi

      OK=1;
      for EPOOL in "${DANBOORU_POOL_MATCH[@]}"; do
         [[ "$EPOOL" != "$POOL" ]] && { OK=0; continue; }
         OK=1; break
      done

      if [[ $OK -eq 0 ]]; then
         echo "[!] no pool matched: $DURL"
         continue
      fi

      # Check tags
      OK=1; BTAG=""
      for ETAG in "${DANBOORU_TAG_FILTER[@]}"; do
         echo "$TAGS" | grep -Fw "$ETAG" &> /dev/null
         [[ $? -eq 1 ]] && continue
         OK=0; BTAG="$ETAG"
         break
      done

      if [[ $OK -eq 0 ]]; then
         echo "[!] block tag [$BTAG]: $DURL"
         continue
      fi

      OK=1
      for ETAG in "${DANBOORU_TAG_MATCH[@]}"; do
         echo "$TAGS" | grep -Fw "$ETAG" &> /dev/null
         [[ $? -eq 1 ]] && { OK=0; continue; }
         OK=1; break
      done

      if [[ $OK -eq 0 ]]; then
         echo "[!] no tag matched: $DURL"
         continue
      fi

      # Check resolution
      OK=1
      RES="${WIDTH}x${HEIGHT}"
      for ERES in "${DANBOORU_LIMIT_DIMENSIONS[@]}"; do
         [[ "$ERES" != "$RES" ]] && { OK=0; continue; }
         OK=1; break
      done

      if [[ $OK -eq 0 ]]; then
         echo "[!] block resolution [$RES]: $DURL"
         continue
      fi

      if [[ $VERBOSE -eq 1 ]]; then
         echo "ID: $IDS[$i]"
         echo "MD5: $MD5"
         echo "URL: $URL"
         echo "DURL: $DURL"
         echo "EXT: $EXT"
         echo "POOL: $POOL"
         echo ""
      fi

      # Check picture
      check_picture "$URL" "$DURL" "$TAGS" "$CREATED_AT" "$JSON"

      # Wait for forks
      while [[ $(jobs -p | wc -l) -gt $FORK_LIMIT ]]; do
         sleep 1
      done
   done

   # Wait for subprocesses
   while [[ $(jobs -p | wc -l) -gt 1 ]]; do
      sleep 1
   done
}

# Lets do it
check_deps
usage $@
lock
main $@
unlock
